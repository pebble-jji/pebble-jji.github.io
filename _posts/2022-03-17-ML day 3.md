---
layout : single
title : "3/17 (목) ML day 3" 
---

## K-최근접 이웃 모델 이용하여 손동작 분류하기

머신러닝 3일차인 나는 그동안 배운거라곤 k-최근접 이웃 모델 밖에 없는데  
데이콘에 모델 제출을 해야해서 아는 거로 했다.  
  
다행히도 배운게 분류모델이라서 다른 것을 알아보거나 하지 않아도 돼서 다행이었다.  

필요한 라이브러리들을 불러온다.


```
import numpy as np
import  pandas as pd 
import  matplotlib.pyplot as plt
import csv
```

### 데이터

```
train = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/train.csv')

train = train.drop('id', axis = 1)

test = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/test.csv')

test = test.drop('id', axis = 1)
```

### EDA

간단한 EDA를 진행했다.

#### 결측치 

먼저 결측치가 있는지 보겠다. 아래 코드는 데이콘의 EDA를 인용했다.

```
def check_missing_col(dataframe):
    missing_col = []
    counted_missing_col = 0
    for i, col in enumerate(dataframe.columns):
        missing_values = sum(dataframe[col].isna())
        is_missing = True if missing_values >= 1 else False
        if is_missing:
            counted_missing_col += 1
            print(f'결측치가 있는 컬럼은: {col}입니다')
            print(f'해당 컬럼에 총 {missing_values}개의 결측치가 존재합니다.')
            missing_col.append([col, dataframe[col].dtype])
    if counted_missing_col == 0:
        print('결측치가 존재하지 않습니다')
    return missing_col

missing_col = check_missing_col(train)
```

결측치가 없다고 나온다.

#### 여러가지 기초 통계량

 **describe()** 함수를 통해 기초통계량을 보겠다.

```
train.describe()
```

* 클래스는 0,1,2,3으로 총 4개임을 알 수 있다.  


#### 클래스별 개수

```
plt.hist(train['target'])

plt.show()
```

대강 4가지 클래스 모두 비슷한 빈도를 보인다. 


### 스케일링

```
from sklearn.preprocessing import StandardScaler

ss = StandardScaler()

ss.fit(train.drop('target', axis = 1))

train_scaled = ss.transform(train.drop('target', axis = 1))

test_scaled = ss.transform(test)
```


### k-최근접 이웃 모델 불러오기

```
from sklearn.neighbors import KNeighborsClassifier

kn = KNeighborsClassifier() 

kn.fit(train_scaled,train['target'])

print(kn.predict(test_scaled))

```

모델 객체를 생성한 후 예측값을 만든다.

```
import csv

id = list(range(1,len(test)+1))
target = list(kn.predict(test))

with open('/content/sample_data/answer.csv','w',newline='') as f :
  writer = csv.writer(f)
  writer.writerow(id)
  writer.writerow(target)
  ```

  예측값을 csv 파일로 저장한다.  


  무지성 원툴이라서 결과는 그리 좋지 못했다ㅋㅋㅋㅋㅋ첫 제출로 의의를 둔다.